# MHGA (McDonald's Hamburger Game Application)

> **Unreal Engine 5 ê¸°ë°˜ í–„ë²„ê±° ì œì‘ ì‹œë®¬ë ˆì´ì…˜ ê²Œì„**  
> ë¦¬ìŠ¨ ì„œë²„ ë°©ì‹ì˜ ë©€í‹°í”Œë ˆì´ì–´ í˜‘ë™ ê²Œì„í”Œë ˆì´ ì§€ì›

---

## ğŸ“‹ í”„ë¡œì íŠ¸ ê°œìš”

**MHGA**ëŠ” ì‹¤ì œ í–„ë²„ê±° ê°€ê²Œì˜ ì•„ë¥´ë°”ì´íŠ¸ í™˜ê²½ì„ ì‹œë®¬ë ˆì´ì…˜í•œ í˜‘ë™ ê²Œì„ì…ë‹ˆë‹¤. í”Œë ˆì´ì–´ëŠ” ì†ë‹˜ ì£¼ë¬¸ ì ‘ìˆ˜ë¶€í„° ì¬ë£Œ ì¡°ë¦¬, í–„ë²„ê±° ì œì‘, ìŒì‹ ì „ë‹¬ê¹Œì§€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ê²½í—˜í•˜ë©°, ë™ë£Œë“¤ê³¼ í˜‘ë ¥í•˜ì—¬ ëª°ë ¤ë“œëŠ” ì†ë‹˜ë“¤ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ëŒ€í•´ì•¼ í•©ë‹ˆë‹¤.

### ê°œë°œ í™˜ê²½
- **ì—”ì§„**: Unreal Engine 5.6
- **ê°œë°œ ì–¸ì–´**: C++ / Blueprint
- **ë„¤íŠ¸ì›Œí¬**: Listen Server ê¸°ë°˜ ë©€í‹°í”Œë ˆì´
- **ê°œë°œ ì¸ì›**: 3ëª… (ê¹€í™ë²”, í™©ê·œí™˜, í—ˆì§€ì›…)

### í”„ë¡œì íŠ¸ ì»¨ì…‰ (README ê¸°ë°˜)
- **í–„ë²„ê±° ì•„ë¥´ë°”ì´íŠ¸ ì‹œë®¬ë ˆì´ì…˜**
- í–„ë²„ê±° ê°€ê²Œì˜ ì•„ë¥´ë°”ì´íŠ¸ë¥¼ ê³„ì‚°ë¶€í„° ìŒì‹ ì¡°ë¦¬ê¹Œì§€ ê²½í—˜
- ë™ë£Œë“¤ê³¼ í˜‘ì‹¬í•˜ì—¬ ì†ë‹˜ë“¤ì´ ëª°ë ¤ë“œëŠ” í–„ë²„ê±° ê°€ê²Œ ê²½ì˜ ëª¨ì˜ì‹¤í—˜
- ì‹¤ì œ ê·¼ë¬´ í™˜ê²½ê³¼ ë¹„ìŠ·í•œ í™˜ê²½ êµ¬ì„±
- ë ˆì‹œí”¼ëŠ” ë²½ì— ë¶™ì–´ìˆê±°ë‚˜ ì•”ê¸°í•´ì•¼ í•¨

### ì£¼ìš” íŠ¹ì§•
- âœ… **ë¦¬ìŠ¨ ì„œë²„ ê¸°ë°˜ ë©€í‹°í”Œë ˆì´**: í˜‘ë™ í”Œë ˆì´ ì§€ì›
- âœ… **AI ì†ë‹˜ ì‹œìŠ¤í…œ**: FSM ê¸°ë°˜ì˜ ì§€ëŠ¥í˜• ì†ë‹˜ í–‰ë™ íŒ¨í„´
- âœ… **ì‹¤ì œ ë ˆì‹œí”¼ ê¸°ë°˜ ì¡°ë¦¬ ì‹œìŠ¤í…œ**: ë°ì´í„° í…Œì´ë¸”ì„ í™œìš©í•œ ì •í™•í•œ ë©”ë‰´ êµ¬ì„±
- âœ… **ë¬¼ë¦¬ ê¸°ë°˜ ìƒí˜¸ì‘ìš©**: ì¬ë£Œ ì§‘ê¸°, ì¡°ë¦¬, í¬ì¥ ë“± ëª¨ë“  ì‘ì—…ì´ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ê¸°ë°˜
- âœ… **3D UI ì‹œìŠ¤í…œ**: Widget Interactionì„ í™œìš©í•œ POS ì‹œìŠ¤í…œ
- âœ… **ë™ì  ì†ë‹˜ ê´€ë¦¬**: ìµœëŒ€ ì†ë‹˜ ìˆ˜ ì œí•œ ë° ëŒ€ê¸°ì—´ ì‹œìŠ¤í…œ

---

## ğŸ® í•µì‹¬ ì‹œìŠ¤í…œ êµ¬ì¡°

### 1. ë„¤íŠ¸ì›Œí¬ ì•„í‚¤í…ì²˜

**ë¦¬ìŠ¨ ì„œë²„ êµ¬ì¡°ë¥¼ í†µí•œ íš¨ìœ¨ì ì¸ ë©€í‹°í”Œë ˆì´ êµ¬í˜„**

#### ì£¼ìš” êµ¬í˜„ ì‚¬í•­
- **Replication ì‹œìŠ¤í…œ**: Actor ë° Component ë ˆë²¨ì—ì„œì˜ ë°ì´í„° ë™ê¸°í™”
- **RPC(Remote Procedure Call)**: Server/Client/Multicast RPCë¥¼ í™œìš©í•œ ìƒíƒœ ì „íŒŒ
- **Authority ê¸°ë°˜ ë¡œì§ ë¶„ë¦¬**: ì„œë²„ì—ì„œë§Œ ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” ê²Œì„ ë¡œì§ ë³´í˜¸

```cpp
// GameStateì—ì„œ Counter POS ë³µì œ
void AMHGAGameState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    DOREPLIFETIME(AMHGAGameState, Counter);
}
```

#### ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™” ì „ëµ
- **ì¬ë£Œ ë° Props**: `bReplicates = true` + `SetReplicateMovement(true)`ë¡œ ë¬¼ë¦¬ ê¸°ë°˜ ë™ì‘ ë™ê¸°í™”
  ```cpp
  // IngredientBase ìƒì„±ì
  AIngredientBase::AIngredientBase()
  {
      bReplicates = true;
      AActor::SetReplicateMovement(true);
  }
  
  // BeginPlayì—ì„œ í´ë¼ì´ì–¸íŠ¸ ë¬¼ë¦¬ ë¹„í™œì„±í™”
  void AIngredientBase::BeginPlay()
  {
      if (HasAuthority() == false)
      {
          Mesh->SetSimulatePhysics(false);
          Mesh->SetEnableGravity(false);
      }
  }
  ```
- **UI ìƒí˜¸ì‘ìš©**: PlayerControllerë¥¼ í†µí•œ Server RPC â†’ Counter Actorì˜ Multicast RPC ì²´ì¸
- **ì†ë‹˜ AI**: ì„œë²„ì—ì„œë§Œ FSM ë¡œì§ ì‹¤í–‰, ê²°ê³¼ë§Œ ë³µì œ

---

### 2. AI ì†ë‹˜ ì‹œìŠ¤í…œ

**ìœ í•œ ìƒíƒœ ë¨¸ì‹ (FSM) ê¸°ë°˜ì˜ ì†ë‹˜ í–‰ë™ AI**

#### ì†ë‹˜ ìƒíƒœ ë‹¤ì´ì–´ê·¸ë¨
```
ì…ì¥ â†’ ëŒ€ê¸°ì—´ ì´ë™ or ë°°íšŒ 
    â†’ ì£¼ë¬¸ 
    â†’ ìŒì‹ ëŒ€ê¸°(ë°°íšŒ) 
    â†’ í”½ì—…ì¡´ ì´ë™ 
    â†’ í”½ì—…ì¡´ ëŒ€ê¸°
    â†’ ìŒì‹ ìˆ˜ë ¹ ë° ê²€ì¦ 
    â†’ í‡´ì¥
```

#### FSM êµ¬ì¡° (CustomerFSM)
ì´ 9ê°€ì§€ ìƒíƒœë¥¼ ê°€ì§„ ìœ í•œ ìƒíƒœ ë¨¸ì‹ ìœ¼ë¡œ ì†ë‹˜ì˜ í–‰ë™ì„ ì œì–´í•©ë‹ˆë‹¤.

```cpp
enum class EAIState : uint8
{
    None,              // ì´ˆê¸° ìƒíƒœ
    GoingToLine,       // ì¤„ ì„œëŸ¬ ì´ë™ ì¤‘
    WaitingInLine,     // ì¤„ ì„œì„œ ëŒ€ê¸° ì¤‘
    Wandering,         // ë°°íšŒ ì¤‘
    Ordering,          // ì£¼ë¬¸ ì¤‘
    WaitingForFood,    // ìŒì‹ ëŒ€ê¸° ì¤‘
    GoingToPickup,     // í”½ì—…ì¡´ ì´ë™ ì¤‘
    WaitingForPickup,  // í”½ì—…ì¡´ ëŒ€ê¸° ì¤‘
    Exit               // í‡´ì¥
};
```

#### ì£¼ìš” ê¸°ëŠ¥

**1. ëŒ€ê¸°ì—´ ê´€ë¦¬ ì‹œìŠ¤í…œ**
- ë¹ˆ ìë¦¬ê°€ ìˆìœ¼ë©´ ì¦‰ì‹œ ì¤„ì„œê¸°, ì—†ìœ¼ë©´ ë°°íšŒí•˜ë©° ëŒ€ê¸°
- ì†ë‹˜ì´ ì£¼ë¬¸ ì™„ë£Œ ì‹œ ìë™ìœ¼ë¡œ ëŒ€ê¸°ì—´ ì•ë‹¹ê¹€
- ëŒ€ê¸° ì¤‘ì¸ ì†ë‹˜ì„ ìˆœì°¨ì ìœ¼ë¡œ í˜¸ì¶œ

```cpp
void ACustomerManager::UpdateWaitingPosition()
{
    for (int32 i = 1; i < waitingCustomers.Num(); ++i)
    {
        if (waitingCustomers[i] != nullptr && waitingCustomers[i - 1] == nullptr)
        {
            // ì•ìë¦¬ë¡œ ì´ë™ ëª…ë ¹
            ACustomerAI* customerToMove = waitingCustomers[i];
            customerToMove->fsm->MoveToTarget(waitingPoints[i-1]);
            waitingCustomers[i-1] = waitingCustomers[i];
            waitingCustomers[i] = nullptr;
        }
    }
}
```

**2. ë°°íšŒ ì‹œìŠ¤í…œ**
- NavigationSystemì„ í™œìš©í•œ NavMesh ê¸°ë°˜ ëœë¤ ì´ë™
- 3~5ì´ˆ ê°„ê²©ìœ¼ë¡œ ìƒˆë¡œìš´ ëª©ì ì§€ ì„¤ì •
- íƒ€ì´ë¨¸ë¥¼ í™œìš©í•œ ë¹„ë™ê¸° ì²˜ë¦¬

**3. ì£¼ë¬¸ ì‹œìŠ¤í…œ**
- Enum ê¸°ë°˜ ë©”ë‰´ ì„ íƒ (BigMac, BTD, QPC, Shanghai, Shrimp)
- UMG ìœ„ì ¯ì„ í†µí•œ ë§í’ì„  UI í‘œì‹œ
- ì£¼ë¬¸ ì™„ë£Œ ì‹œ ìë™ìœ¼ë¡œ ìŒì‹ ëŒ€ê¸° ìƒíƒœë¡œ ì „í™˜

**4. ìŒì‹ ê²€ì¦ ì‹œìŠ¤í…œ**
- í”½ì—…ì¡´ì—ì„œ ìŒì‹ ì´ë¦„ê³¼ ì£¼ë¬¸í•œ ë©”ë‰´ ë¹„êµ
- ì¼ì¹˜ ì‹œ ë§Œì¡± í‘œì‹œ, ë¶ˆì¼ì¹˜ ì‹œ ë¶ˆë§Œ í‘œì‹œ
- í‰ì  ì‹œìŠ¤í…œ ì—°ë™ ì¤€ë¹„ (TODO)

```cpp
void UCustomerFSM::CheckAndTakeFood()
{
    if (MyPickupZone->HasFood())
    {
        AHamburger* TakenHamburger = Cast<AHamburger>(MyPickupZone->TakeFood());
        FString OrderedMenuName = // Enumì„ Stringìœ¼ë¡œ ë³€í™˜
        FString TakenBurgerName = TakenHamburger->GetBurgerName();
        
        if (OrderedMenuName == TakenBurgerName)
        {
            me->ShowReputationText(true);  // ë§Œì¡±
        }
        else
        {
            me->ShowReputationText(false); // ë¶ˆë§Œ
        }
    }
}
```

**5. ì†ë‹˜ ë§¤ë‹ˆì € (CustomerManager)**
- íƒ€ì´ë¨¸ ê¸°ë°˜ ìë™ ìŠ¤í° ì‹œìŠ¤í…œ
- ìµœëŒ€ ì¸ì› ì œí•œ ê´€ë¦¬ (MaxSpawnedCustomers)
- í”½ì—… ëŒ€ê¸°ì—´ ê´€ë¦¬ ë° í˜¸ì¶œ ì‹œìŠ¤í…œ

---

### 3. ì¡°ë¦¬ ì‹œìŠ¤í…œ

**ë¬¼ë¦¬ ê¸°ë°˜ ìƒí˜¸ì‘ìš©ê³¼ ìƒíƒœ ë¨¸ì‹ ì„ ê²°í•©í•œ ì¡°ë¦¬ ë©”ì»¤ë‹ˆì¦˜**

#### ì¬ë£Œ ì‹œìŠ¤í…œ (Ingredient System)

**ì¬ë£Œ í´ë˜ìŠ¤ ê³„ì¸µ êµ¬ì¡°**
```
IngredientBase (ê¸°ë³¸ ì¬ë£Œ í´ë˜ìŠ¤, IngType = None)
â”œâ”€â”€ BottomBread (IngType = BottomBread)
â”œâ”€â”€ MiddleBread (IngType ë¯¸ì„¤ì •)
â”œâ”€â”€ TopBread (IngType = TopBread)
â”œâ”€â”€ Patty (IngType = Patty, ì¡°ë¦¬ ìƒíƒœ í¬í•¨)
â”œâ”€â”€ Cheese (IngType = Cheese)
â”œâ”€â”€ Lettuce (IngType ë¯¸ì„¤ì •)
â”œâ”€â”€ Tomato (IngType ë¯¸ì„¤ì •)
â”œâ”€â”€ Onion (IngType = Onion)
â”œâ”€â”€ Pickle (IngType = Pickle)
â””â”€â”€ SauceBottle (IngType = None, ë°œì‚¬ ê¸°ëŠ¥)
```

**ì£¼ìš” êµ¬í˜„ ì¬ë£Œ**
- `BottomBread`, `TopBread`: í–„ë²„ê±° ìƒí•˜ ë¹µ
- `Patty`: 3ë‹¨ê³„ ì¡°ë¦¬ ìƒíƒœ (Raw â†’ Cooked â†’ Overcooked)
- `Cheese`, `Onion`, `Pickle`: í† í•‘ ì¬ë£Œ
- `SauceBottle`: Line Trace ê¸°ë°˜ ì†ŒìŠ¤ ë°œì‚¬

**ì¬ë£Œ Enum ì •ì˜**
```cpp
enum class EIngredient : uint8
{
    None, BottomBread, MiddleBread, TopBread,
    Patty, Lettuce, Tomato, Onion,
    Cheese, Pickle, Sauce, ShanghaiPortion, ShrimpPortion
};
```

#### íŒ¨í‹° ì¡°ë¦¬ ì‹œìŠ¤í…œ

**CookingArea í´ë˜ìŠ¤**ë¥¼ í†µí•œ 3ë‹¨ê³„ ì¡°ë¦¬ ìƒíƒœ êµ¬í˜„

```cpp
enum class EPattyCookState : uint8
{
    Raw,        // ë‚ ê²ƒ
    Cooked,     // ì ì ˆíˆ êµ¬ì›Œì§
    Overcooked  // íƒ€ë²„ë¦¼
};
```

**ì¡°ë¦¬ í”„ë¡œì„¸ìŠ¤**
1. **Overlap ì‹œì‘**: íŒ¨í‹°ê°€ ì¡°ë¦¬ ì˜ì—­ì— ì§„ì…í•˜ë©´ íƒ€ì´ë¨¸ ì‹œì‘
2. **Cooked ì „í™˜**: cookingTime(3ì´ˆ) ê²½ê³¼ ì‹œ ìƒ‰ìƒ ë³€ê²½ + ìƒíƒœ ë³€ê²½
3. **Overcooked ì „í™˜**: OvercookTime(5ì´ˆ) ì¶”ê°€ ê²½ê³¼ ì‹œ ê²€ì€ìƒ‰ + ì˜¤ë²„ì¿¡ ìƒíƒœ

```cpp
void ACookingArea::CookPatty(AActor* actor)
{
    APatty* PattyActor = Cast<APatty>(actor);
    if (PattyActor)
    {
        PattyActor->SetCookState(EPattyCookState::Cooked);
        ChangeColor(actor, cookedColor);
        
        // ì˜¤ë²„ì¿¡ íƒ€ì´ë¨¸ ì‹œì‘
        FTimerHandle overcookTimerHandle;
        GetWorld()->GetTimerManager().SetTimer(
            overcookTimerHandle, 
            this, 
            &ACookingArea::OvercookPatty, 
            OvercookTime, 
            false
        );
    }
}
```

#### ì†ŒìŠ¤ ë°œì‚¬ ì‹œìŠ¤í…œ

**SauceBottle í´ë˜ìŠ¤**ì˜ íŠ¹ìˆ˜ ê¸°ëŠ¥
- Line Traceë¥¼ í†µí•œ ì†ŒìŠ¤ ì ìš© ëŒ€ìƒ íƒì§€
- Arrow Componentë¡œ ë°œì‚¬ ë°©í–¥ ì‹œê°í™”
- ì‹¤ì‹œê°„ ë¬¼ë¦¬ ê¸°ë°˜ ì†ŒìŠ¤ ìŠ¤í°

```cpp
void ASauceBottle::ShootSauce()
{
    FVector StartLoc = Arrow->GetComponentLocation();
    FVector EndLoc = StartLoc + GetActorUpVector() * 200.f;
    
    bool bShot = GetWorld()->LineTraceSingleByChannel(
        HitResult, StartLoc, EndLoc, ECC_PhysicsBody, Params
    );
    
    if (bShot && SauceClass)
    {
        FVector SpawnLoc = HitResult.ImpactPoint + FVector(0, 0, 20);
        GetWorld()->SpawnActor(SauceClass, &SpawnLoc, &FRotator::ZeroRotator);
    }
}
```

---

### 4. í¬ì¥ ë° ë ˆì‹œí”¼ ê²€ì¦ ì‹œìŠ¤í…œ

**WrappingPaper í´ë˜ìŠ¤ë¥¼ í†µí•œ í–„ë²„ê±° ì™„ì„± ë° ê²€ì¦**

#### ì‘ë™ ì›ë¦¬

**1. ì¬ë£Œ ì¶”ì **
- Box Collisionì„ í†µí•œ Overlap ì´ë²¤íŠ¸ ê°ì§€
- ì¬ë£Œ ì¢…ë¥˜ë³„ ìˆ˜ëŸ‰ ì¹´ìš´íŠ¸
- TArray<FIngredientStack> êµ¬ì¡°ë¡œ ê´€ë¦¬

```cpp
struct FIngredientStack
{
    EIngredient IngredientId;
    int32 Quantity;
};
```

**2. í¬ì¥ ì¡°ê±´ ê²€ì¦**
```cpp
bool AWrappingPaper::HasBreadPair() const
{
    // TopBreadì™€ BottomBreadê°€ ê°ê° 1ê°œ ì´ìƒ í•„ìš”
    int32 Q_TBread = 0, Q_BBread = 0;
    for (const FIngredientStack& tmp : OnAreaIngredients)
    {
        if (tmp.IngredientId == EIngredient::TopBread) Q_TBread++;
        if (tmp.IngredientId == EIngredient::BottomBread) Q_BBread++;
    }
    return Q_TBread >= 1 && Q_BBread >= 1;
}

bool AWrappingPaper::HasExtraIngredient() const
{
    // ë¹µ ì™¸ì— ë‹¤ë¥¸ ì¬ë£Œê°€ 1ê°œ ì´ìƒ í•„ìš”
    int32 count = 0;
    for (const FIngredientStack& tmp : OnAreaIngredients)
    {
        if (!(tmp.IngredientId == EIngredient::BottomBread || 
              tmp.IngredientId == EIngredient::TopBread))
            count++;
    }
    return count > 0;
}
```

**3. ë ˆì‹œí”¼ ë§¤ì¹­ ì•Œê³ ë¦¬ì¦˜**

DataTableì„ í™œìš©í•œ ì •í™•í•œ ë ˆì‹œí”¼ ë¹„êµ

```cpp
EBurgerMenu AWrappingPaper::FindMatchingRecipe(
    UDataTable* DT, 
    const TArray<FIngredientStack>& WrapperIngr)
{
    TMap<EIngredient, int32> WrapMap = MakeMapFromArray(WrapperIngr);
    TArray<FBurgerRecipe*> AllRows;
    DT->GetAllRows<FBurgerRecipe>(TEXT("FBurgerRecipe"), AllRows);
    
    for (FBurgerRecipe* Row : AllRows)
    {
        TMap<EIngredient, int32> RecipeMap = MakeMapFromArray(Row->Ingredients);
        
        // ì¬ë£Œ ìˆ˜ê°€ ë‹¤ë¥´ë©´ ìŠ¤í‚µ
        if (RecipeMap.Num() != WrapMap.Num()) continue;
        
        // ëª¨ë“  ì¬ë£Œì™€ ìˆ˜ëŸ‰ì´ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦
        bool isMatched = true;
        for (const auto& Pair : RecipeMap)
        {
            const int32* WrapQty = WrapMap.Find(Pair.Key);
            if (WrapQty == nullptr || *WrapQty != Pair.Value)
            {
                isMatched = false;
                break;
            }
        }
        
        if (isMatched) return Row->BurgerName;
    }
    
    return EBurgerMenu::WrongBurger;
}
```

**4. í–„ë²„ê±° ìƒì„± ë° ì •ë¦¬**
```cpp
void AWrappingPaper::CompleteWrapping()
{
    // ë ˆì‹œí”¼ ë§¤ì¹­
    EBurgerMenu CreatedBurgerName = FindMatchingRecipe(
        BurgerDataTable, 
        OnAreaIngredients
    );
    
    // í–„ë²„ê±° ìŠ¤í°
    AHamburger* SpawnedBurger = GetWorld()->SpawnActor<AHamburger>(
        BurgerClass, 
        this->GetActorTransform()
    );
    SpawnedBurger->SetName(BurgerMenuName);
    
    // ì¬ë£Œ ë° í¬ì¥ì§€ ì •ë¦¬
    DestroyIngredients();
}
```

#### ì§€ì› ë©”ë‰´
```cpp
enum class EBurgerMenu : uint8
{
    None,
    WrongBurger,  // ì˜ëª»ëœ ì¡°í•©
    BigMac,       // ë¹…ë§¥
    BTD,          // ë² ì´ì»¨ í† ë§ˆí†  ë””ëŸ­ìŠ¤
    QPC,          // ì¿¼í„° íŒŒìš´ë“œ ì¹˜ì¦ˆ
    Shanghai,     // ìƒí•˜ì´ ë²„ê±°
    Shrimp        // ìƒˆìš° ë²„ê±°
};
```

---

### 5. POS(Point of Sale) ì‹œìŠ¤í…œ

**3D Widget Interactionì„ í™œìš©í•œ ì‹¤ì‹œê°„ ì£¼ë¬¸ ê´€ë¦¬**

#### ì‹œìŠ¤í…œ êµ¬ì¡°

**CounterPOS (Actor)**
- Static Meshë¡œ ëœ ì¹´ìš´í„° ëª¨ë¸
- Widget Componentë¥¼ í†µí•œ 3D UI í‘œì‹œ
- ë„¤íŠ¸ì›Œí¬ ë³µì œë¥¼ í†µí•œ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ë™ê¸°í™”

```cpp
ACounterPOS::ACounterPOS()
{
    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));
    WidgetComponent = CreateDefaultSubobject<UWidgetComponent>(TEXT("Widget"));
    
    bReplicates = true;
    bAlwaysRelevant = true;
    WidgetComponent->SetIsReplicated(true);
}
```

#### ì£¼ë¬¸ ê´€ë¦¬ êµ¬ì¡°

**FOrderArray êµ¬ì¡°ì²´**
```cpp
struct FOrderArray
{
    ACustomerAI* Customer;           // ì£¼ë¬¸í•œ ì†ë‹˜
    TArray<EBurgerMenu> Menus;       // ì£¼ë¬¸ ë©”ë‰´ ë¦¬ìŠ¤íŠ¸
};

// CounterPOSì—ì„œ ê´€ë¦¬
TMap<int32, FOrderArray> OrderMap;  // ì£¼ë¬¸ë²ˆí˜¸ â†’ ì£¼ë¬¸ì •ë³´
```

#### UI êµ¬ì„±

**1. CounterUI (ë©”ì¸ UI)**
- **CustomerCanvas**: ì£¼ë¬¸ ì™„ë£Œ ëª©ë¡ í‘œì‹œ
  - UniformGridPanelë¡œ 5ì—´ ê·¸ë¦¬ë“œ êµ¬ì„±
  - ê° ì£¼ë¬¸ì€ CustomerButtonUIë¡œ í‘œí˜„
  
- **OrderCanvas**: ë©”ë‰´ ì„ íƒ ë° ì£¼ë¬¸ ì ‘ìˆ˜
  - MenuGrid: ë™ì ìœ¼ë¡œ ìƒì„±ë˜ëŠ” ë©”ë‰´ ë²„íŠ¼
  - SelectedListBox: í˜„ì¬ ì„ íƒëœ ë©”ë‰´ ë¦¬ìŠ¤íŠ¸
  - ì£¼ë¬¸/ì‚­ì œ ë²„íŠ¼

**2. MenuButtonUI (ë©”ë‰´ ë²„íŠ¼)**
```cpp
void UMenuButtonUI::Init(const EBurgerMenu InName, UCounterUI* InOwner)
{
    MenuName = InName;
    CounterUI = InOwner;
    // Enumì„ DisplayNameìœ¼ë¡œ ë³€í™˜í•˜ì—¬ í‘œì‹œ
    TEXT_MenuName->SetText(
        StaticEnum<EBurgerMenu>()->GetDisplayNameTextByValue(
            static_cast<int64>(MenuName)
        )
    );
}
```

**3. CustomerButtonUI (ì£¼ë¬¸ ë²ˆí˜¸ ë²„íŠ¼)**
```cpp
class UCustomerButtonUI : public UUserWidget
{
    int32 Num;                      // ì£¼ë¬¸ ë²ˆí˜¸
    TArray<EBurgerMenu> Menus;      // ì£¼ë¬¸ ë©”ë‰´
    ACustomerAI* Customer;          // ì†ë‹˜ ì°¸ì¡° (ë¯¸ì‚¬ìš©)
    
    void Init(TArray<EBurgerMenu> InMenu, int32 InNum, UCounterUI* InOwner);
};
```
- ì£¼ë¬¸ ë²ˆí˜¸ í‘œì‹œ
- í´ë¦­ ì‹œ í•´ë‹¹ ì£¼ë¬¸ì˜ ë©”ë‰´ ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
- ì¤€ë¹„ ì™„ë£Œ ì²˜ë¦¬ ê¸°ëŠ¥

#### ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™” íë¦„

**ì£¼ë¬¸ ì ‘ìˆ˜ í”„ë¡œì„¸ìŠ¤**
```
1. í”Œë ˆì´ì–´ê°€ ë©”ë‰´ ë²„íŠ¼ í´ë¦­
   â†“
2. PlayerController::ServerRPC_AddMenuToList() [Client â†’ Server]
   â†“
3. CounterPOS::MulticastRPC_AddMenuToList() [Server â†’ All Clients]
   â†“
4. CounterUI::AddMenuToListRPC() [ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ì„œ UI ì—…ë°ì´íŠ¸]
```

**ì£¼ë¬¸ ì™„ë£Œ í”„ë¡œì„¸ìŠ¤**
```cpp
void UCounterUI::OrderMenuBtnRPC()
{
    // ì£¼ë¬¸ ì €ì¥
    PosActor->OrderMap.FindOrAdd(PosActor->OrderNum) = 
        {PosActor->GetCustomer(), OrderList};
    
    // ì£¼ë¬¸ ë²ˆí˜¸ ë²„íŠ¼ ìƒì„±
    UCustomerButtonUI* NewCustomerBtn = CreateWidget<UCustomerButtonUI>(...);
    NewCustomerBtn->Init(OrderList, PosActor->OrderNum, this);
    CustomerGrid->AddChildToUniformGrid(NewCustomerBtn, Row, Col);
    
    // ì˜ìˆ˜ì¦ ì¶œë ¥ (ì„œë²„ì—ì„œë§Œ)
    if (PosActor->HasAuthority())
    {
        AReceiptActor* NewReceipt = GetWorld()->SpawnActor<AReceiptActor>(...);
        NewReceipt->MulticastRPC_Init(OrderNum, MenuStrings);
    }
    
    // AI ì†ë‹˜ ì£¼ë¬¸ ì™„ë£Œ ì²˜ë¦¬
    if (PosActor->GetCustomer() != nullptr)
        PosActor->GetCustomer()->fsm->FinishOrder();
}
```

#### ì˜ìˆ˜ì¦ ì‹œìŠ¤í…œ

**ReceiptActor í´ë˜ìŠ¤**
- Canvas Render Targetì„ í™œìš©í•œ ë™ì  í…ìŠ¤íŠ¸ ë Œë”ë§
- ì£¼ë¬¸ ë²ˆí˜¸ì™€ ë©”ë‰´ ë¦¬ìŠ¤íŠ¸ë¥¼ í…ìŠ¤ì²˜ë¡œ ë³€í™˜
- ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì ìš©ìœ¼ë¡œ í˜„ì‹¤ê° ìˆëŠ” ì¶œë ¥ íš¨ê³¼

```cpp
void AReceiptActor::OnUpdateCanvas(UCanvas* Canvas, int32 Width, int32 Height)
{
    // ë°°ê²½ í°ìƒ‰
    FCanvasTileItem TileItem(FVector2D(0, 0), 
                             FVector2D(Width, Height), 
                             FLinearColor::White);
    Canvas->DrawItem(TileItem);
    
    // ì£¼ë¬¸ ë²ˆí˜¸ í¬ê²Œ í‘œì‹œ
    FString OrderText = FString::Printf(TEXT("#%d"), OrderNum);
    // ... í…ìŠ¤íŠ¸ ë Œë”ë§
    
    // ë©”ë‰´ ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
    for (const FString& M : MenuList)
    {
        FCanvasTextItem MenuItem(...);
        Canvas->DrawItem(MenuItem);
    }
}
```

---

### 6. ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ

**InteractComponentë¥¼ í†µí•œ í†µí•© ìƒí˜¸ì‘ìš© ê´€ë¦¬**

#### ì‹œìŠ¤í…œ ê°œìš”

í”Œë ˆì´ì–´ê°€ ì›”ë“œì˜ ë‹¤ì–‘í•œ ì˜¤ë¸Œì íŠ¸ì™€ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆëŠ” ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜ ì‹œìŠ¤í…œ

**ì§€ì› ìƒí˜¸ì‘ìš©**
- ì¬ë£Œ/ë„êµ¬ ì§‘ê¸° (Grab)
- ì¬ë£Œ ì»¨í…Œì´ë„ˆì—ì„œ êº¼ë‚´ê¸°
- ë„êµ¬ ì‚¬ìš© (Use)
- ì˜¤ë¸Œì íŠ¸ ë‚´ë ¤ë†“ê¸° (Put)

#### IGrabableProps ì¸í„°í˜ì´ìŠ¤

```cpp
class IGrabableProps
{
    virtual void OnGrabbed(AMHGACharacter* Player) = 0;  // ì§‘í ë•Œ
    virtual void OnPut() = 0;                             // ë‚´ë ¤ë†“ì„ ë•Œ
    virtual void OnUse() = 0;                             // ì‚¬ìš©í•  ë•Œ
    virtual void SetLocation(FVector Loc) = 0;            // ìœ„ì¹˜ ì„¤ì •
};
```

```cpp
class AIngredientBase : public AActor, public IGrabableProps
{
    UPROPERTY(EditAnywhere)
    UStaticMeshComponent* Mesh;
    
    UPROPERTY(EditAnywhere)
    EIngredient IngType = EIngredient::None;
    
    UPROPERTY(EditAnywhere)
    AMHGACharacter* GrabCharacter;  // í˜„ì¬ ì§‘ê³  ìˆëŠ” ìºë¦­í„°
};
```

**ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ í´ë˜ìŠ¤**
- `AIngredientBase` ë° ëª¨ë“  í•˜ìœ„ ì¬ë£Œ í´ë˜ìŠ¤
- `AHamburger` (ì™„ì„±ëœ í–„ë²„ê±°)
- `AFlipper` (íŒ¨í‹° ë’¤ì§‘ê°œ, ìì²´ GrabCharacter í•„ë“œ ë³´ìœ )
- `AReceiptActor` (ì˜ìˆ˜ì¦)

#### ì§‘ê¸° ì‹œìŠ¤í…œ êµ¬í˜„

**1. Sweep ê¸°ë°˜ íƒì§€**
```cpp
void UInteractComponent::GrabProps()
{
    FVector Start = Owner->GetFirstPersonCameraComponent()->GetComponentLocation();
    FVector End = Start + Owner->GetCamera()->GetForwardVector() * GrabDistance;
    
    FCollisionShape Sphere = FCollisionShape::MakeSphere(GrabRadius);
    
    if (GetWorld()->SweepSingleByChannel(Hit, Start, End, ...))
    {
        // WrappingPaper íŠ¹ìˆ˜ ì²˜ë¦¬
        if (AWrappingPaper* wp = Cast<AWrappingPaper>(Hit.GetActor()))
        {
            wp->TryWrap();  // í¬ì¥ ì‹œë„
            return;
        }
        
        // IGrabableProps ì¸í„°í˜ì´ìŠ¤ ì²´í¬
        if (Cast<IGrabableProps>(Hit.GetActor()))
            MulticastRPC_GrabProps(Hit);
            
        // IngContainer íŠ¹ìˆ˜ ì²˜ë¦¬
        else if (AIngContainer* Container = Cast<AIngContainer>(Hit.GetActor()))
        {
            AIngredientBase* Ing = Container->GetIngredient();
            MulticastRPC_InteractIngContainer(Ing);
        }
    }
}
```

**2. ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™”**
```cpp
void UInteractComponent::MulticastRPC_GrabProps_Implementation(FHitResult Hit)
{
    IGrabableProps* GrabInterface = Cast<IGrabableProps>(Hit.GetActor());
    GrabInterface->OnGrabbed(Owner);
    
    // ë¬¼ë¦¬ ë„ê¸°
    Hit.GetComponent()->SetSimulatePhysics(false);
    Hit.GetComponent()->SetCollisionProfileName(TEXT("Grabbed"));
    
    // ì¹´ë©”ë¼ì— ë¶€ì°©
    HoldDistance = FVector::Dist(CameraLocation, ActorLocation);
    HoldDistance = FMath::Clamp(HoldDistance, 50, 200);
    
    Cast<AActor>(GrabInterface)->AttachToComponent(
        Owner->GetFirstPersonCameraComponent(), 
        FAttachmentTransformRules::SnapToTargetNotIncludingScale
    );
    
    GrabInterface->SetLocation(
        CameraLocation + CameraForward * HoldDistance
    );
    
    bIsGrabbed = true;
    GrabbedProp = GrabInterface;
}

// IngredientBaseì˜ OnGrabbed - ë‹¤ë¥¸ í”Œë ˆì´ì–´ê°€ ì§‘ê³  ìˆìœ¼ë©´ ì²˜ë¦¬
void AIngredientBase::OnGrabbed(AMHGACharacter* Player)
{
    if (GrabCharacter != Player && GrabCharacter != nullptr)
    {
        // ì´ì „ì— ì§‘ê³  ìˆë˜ ìºë¦­í„°ê°€ ìˆìœ¼ë©´ ë‚´ë ¤ë†“ê²Œ í•¨
        GrabCharacter->GetInteractComponent()->PutProps();
    }
    GrabCharacter = Player;
}
```

**3. ë‚´ë ¤ë†“ê¸°**
```cpp
void UInteractComponent::PutProps()
{
    if (GrabbedProp)
    {
        GrabbedProp->OnPut();
        
        AActor* P = Cast<AActor>(GrabbedProp);
        if (UPrimitiveComponent* Root = Cast<UPrimitiveComponent>(P->GetRootComponent()))
        {
            // ë¬¼ë¦¬ ë‹¤ì‹œ ì¼œê¸°
            Root->SetSimulatePhysics(true);
            Root->SetCollisionProfileName(TEXT("BlockAllDynamic"));
            P->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
        }
        
        bIsGrabbed = false;
        GrabbedProp = nullptr;
    }
}
```

#### íŠ¹ìˆ˜ ë„êµ¬: Flipper (ë’¤ì§‘ê°œ)

**íŒ¨í‹° ë’¤ì§‘ê¸° êµ¬í˜„**
```cpp
void AFlipper::OnUse()
{
    FVector Start = GrabCharacter->GetCamera()->GetComponentLocation();
    FVector End = Start + GrabCharacter->GetCamera()->GetForwardVector() * 200;
    
    if (GetWorld()->SweepSingleByChannel(Hit, Start, End, ...))
    {
        if (Hit.GetComponent()->IsSimulatingPhysics())
        {
            // ì¹´ë©”ë¼ì˜ Right ë²¡í„° ê¸°ì¤€ìœ¼ë¡œ 180ë„ íšŒì „
            FRotationMatrix CamMatrix(CameraRotation);
            FVector RightVector = CamMatrix.GetScaledAxis(EAxis::Y);
            
            FQuat CurrentQuat = Hit.GetActor()->GetActorQuat();
            FQuat FlipQuat = FQuat(RightVector, FMath::DegreesToRadians(180.f));
            FQuat NewQuat = FlipQuat * CurrentQuat;
            
            Hit.GetActor()->SetActorRotation(NewQuat);
        }
    }
}
```

#### ì¬ë£Œ ì»¨í…Œì´ë„ˆ ì‹œìŠ¤í…œ

**AIngContainer í´ë˜ìŠ¤**
- ë¬´í•œ ì¬ë£Œ ê³µê¸‰ ì‹œìŠ¤í…œ
- Interact ì‹œ ìƒˆ ì¬ë£Œ ì¸ìŠ¤í„´ìŠ¤ ìŠ¤í°

```cpp
class AIngContainer : public AActor
{
    UPROPERTY(EditAnywhere)
    TSubclassOf<AIngredientBase> Ingredient;
    
    AIngredientBase* GetIngredient()
    {
        return GetWorld()->SpawnActor<AIngredientBase>(Ingredient);
    }
};
```

---

### 7. ìºë¦­í„° ë° ì…ë ¥ ì‹œìŠ¤í…œ

**Enhanced Input System ê¸°ë°˜ì˜ 1ì¸ì¹­ ìºë¦­í„° ì»¨íŠ¸ë¡¤**

#### MHGACharacter êµ¬ì¡°

**ì»´í¬ë„ŒíŠ¸ êµ¬ì„±**
- **UCameraComponent**: 1ì¸ì¹­ ì‹œì  ì¹´ë©”ë¼
  - FirstPersonFieldOfView: 70ë„
  - FirstPersonScale: 0.6 (ì† í¬ê¸° ì¡°ì ˆ)
- **UInteractComponent**: ì˜¤ë¸Œì íŠ¸ ìƒí˜¸ì‘ìš©
- **UWidgetInteractionComponent**: 3D UI ìƒí˜¸ì‘ìš©
- **USkeletalMeshComponent**: 1ì¸ì¹­ ë°”ë”” ë©”ì‹œ

#### Enhanced Input Actions

```cpp
// ì´ë™
IA_Move   : Vector2D (WASD)
// ì‹œì 
IA_Look   : Vector2D (ë§ˆìš°ìŠ¤)
// ì§‘ê¸°/ë†“ê¸°
IA_Pick   : Button (E)
// ì‚¬ìš©
IA_Use    : Button (ë§ˆìš°ìŠ¤ ì¢Œí´ë¦­)
// ì•‰ê¸°
IA_Crouch : Button (Ctrl)
```

**ì…ë ¥ ì²˜ë¦¬ ì˜ˆì‹œ**
```cpp
void AMHGACharacter::PickInput(const FInputActionValue& Value)
{
    if (IsLocallyControlled())
        InteractComponent->ServerRPC_InteractProps();
}

void AMHGACharacter::UseInput(const FInputActionValue& Value)
{
    if (IsLocallyControlled())
    {
        // 3D UI ìƒí˜¸ì‘ìš©
        WidgetInteraction->PressPointerKey(EKeys::LeftMouseButton);
        
        // Props ì‚¬ìš©
        InteractComponent->ServerRPC_UseProps();
    }
}
```

#### Widget Interaction êµ¬ì„±

**3D POS ì‹œìŠ¤í…œ ìƒí˜¸ì‘ìš©**
```cpp
WidgetInteraction = CreateDefaultSubobject<UWidgetInteractionComponent>(...);
WidgetInteraction->SetupAttachment(FPSCamComponent);
WidgetInteraction->InteractionDistance = 200.f;
WidgetInteraction->bShowDebug = true;  // ë””ë²„ê·¸ ë¼ì¸ í‘œì‹œ
```

**ë™ì‘ ë°©ì‹**
1. ì¹´ë©”ë¼ ì¤‘ì•™ì—ì„œ Ray ë°œì‚¬
2. Widget Componentì™€ ì¶©ëŒ ì‹œ í´ë¦­ ì´ë²¤íŠ¸ ì „ë‹¬
3. ë¡œì»¬ í”Œë ˆì´ì–´ì—ì„œë§Œ í™œì„±í™”

#### ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ (PlayerAnim)

**Blend Space ê¸°ë°˜ ì´ë™ ì• ë‹ˆë©”ì´ì…˜**
```cpp
class UPlayerAnim : public UAnimInstance
{
    UPROPERTY(BlueprintReadOnly)
    float Speed = 0;      // ì „ì§„/í›„ì§„ ì†ë„
    
    UPROPERTY(BlueprintReadOnly)
    float Dir = 0;        // ì¢Œìš° ì´ë™
    
    UPROPERTY(BlueprintReadOnly)
    float CameraRotX = 0; // ì¹´ë©”ë¼ ìƒí•˜ íšŒì „
    
    UPROPERTY(BlueprintReadOnly)
    bool bIsCrouch = false;
};
```

**ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸**
```cpp
void UPlayerAnim::NativeUpdateAnimation(float DeltaSeconds)
{
    if (OwnerPlayer)
    {
        // ì „í›„ ì´ë™ ì†ë„ (ì •ê·œí™”)
        Speed = FVector::DotProduct(
            OwnerPlayer->GetVelocity(), 
            OwnerPlayer->GetActorForwardVector()
        ) / OwnerPlayer->GetCharacterMovement()->GetMaxSpeed();
        
        // ì¢Œìš° ì´ë™ ì†ë„ (ì •ê·œí™”)
        Dir = FVector::DotProduct(
            OwnerPlayer->GetVelocity(), 
            OwnerPlayer->GetActorRightVector()
        ) / OwnerPlayer->GetCharacterMovement()->GetMaxSpeed();
        
        // ì¹´ë©”ë¼ í”¼ì¹˜
        CameraRotX = -OwnerPlayer->GetBaseAimRotation().Pitch;
        
        // ì•‰ê¸° ìƒíƒœ
        bIsCrouch = OwnerPlayer->GetCharacterMovement()->IsCrouching();
    }
}
```

---

## ğŸ¯ ê¸°ìˆ ì  í•˜ì´ë¼ì´íŠ¸

### 1. ë°ì´í„° ì£¼ë„ ì„¤ê³„ (Data-Driven Design)

**DataTableì„ í™œìš©í•œ ë ˆì‹œí”¼ ê´€ë¦¬**

```cpp
// BurgerData.h
USTRUCT(BlueprintType)
struct FBurgerRecipe : public FTableRowBase
{
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    EBurgerMenu BurgerName;
    
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TArray<FIngredientStack> Ingredients;
};
```

**ì¥ì **
- í”„ë¡œê·¸ë˜ë¨¸ ì—†ì´ ë””ìì´ë„ˆê°€ ë©”ë‰´ ì¶”ê°€/ìˆ˜ì • ê°€ëŠ¥
- ëŸ°íƒ€ì„ì— ë ˆì‹œí”¼ ë³€ê²½ ê°€ëŠ¥
- í™•ì¥ì„± ìš°ìˆ˜ (ì‹ ê·œ ë©”ë‰´ ì¶”ê°€ ìš©ì´)

### 2. íš¨ìœ¨ì ì¸ ë„¤íŠ¸ì›Œí¬ ì„¤ê³„

**RPC í˜¸ì¶œ ì²´ì¸ ìµœì í™”**
```
Client Input 
â†’ ServerRPC (PlayerController) 
â†’ MulticastRPC (Counter Actor) 
â†’ All Clients Update UI
```

**ì´ì **
- ì„œë²„ì—ì„œ ë°ì´í„° ê²€ì¦
- ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ìë™ ë™ê¸°í™”
- í´ë¼ì´ì–¸íŠ¸ ê°„ ë¶ˆì¼ì¹˜ ë°©ì§€

### 3. FSM ê¸°ë°˜ AI ì„¤ê³„

**ëª…í™•í•œ ìƒíƒœ ì „í™˜ ë¡œì§**
```cpp
void UCustomerFSM::SetState(EAIState NewState)
{
    if (CurrentState == NewState) return;
    
    StopWandering();
    CurrentState = NewState;
    
    switch (CurrentState)
    {
    case EAIState::GoingToLine:
        MoveToTarget(orderTarget);
        break;
    case EAIState::Ordering:
        StartOrder();
        break;
    // ...
    }
}
```

**ì¥ì **
- ë””ë²„ê¹… ìš©ì´
- ìƒíƒœ ì¶”ê°€/ìˆ˜ì • ê°„ë‹¨
- ëª…í™•í•œ í–‰ë™ íŒ¨í„´

### 4. ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜

**ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ ì„¤ê³„**
- InteractComponent: ëª¨ë“  ìƒí˜¸ì‘ìš© í†µí•© ê´€ë¦¬
- CustomerFSM: AI í–‰ë™ ë¡œì§ ë¶„ë¦¬
- WidgetInteraction: 3D UI ìƒí˜¸ì‘ìš©

### 5. ë¬¼ë¦¬ ê¸°ë°˜ ê²Œì„í”Œë ˆì´

**ë¦¬ì–¼ë¦¬ì¦˜ì„ ìœ„í•œ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜**
- ëª¨ë“  ì¬ë£ŒëŠ” ì‹¤ì œ ë¬¼ë¦¬ ë²•ì¹™ ì ìš©
- ì§‘ê¸°/ë†“ê¸° ì‹œ ë¬¼ë¦¬ on/off ì „í™˜
- ì˜ìˆ˜ì¦, í–„ë²„ê±° ë“± ì™„ì„±í’ˆë„ ë¬¼ë¦¬ ì ìš©

---

## ğŸ”§ ì‚¬ìš© ê¸°ìˆ  ìŠ¤íƒ

### ì—”ì§„ ë° ì–¸ì–´
- **Unreal Engine 5.6**
- **C++** (í•µì‹¬ ê²Œì„ ë¡œì§)
- **Blueprint** (UI ë° ë ˆë²¨ ë””ìì¸)

### Unreal Engine ëª¨ë“ˆ
```cpp
PublicDependencyModuleNames.AddRange(new string[] {
    "Core",
    "CoreUObject",
    "Engine",
    "InputCore",
    "EnhancedInput",          // Enhanced Input System
    "AIModule",               // AI Navigation
    "NavigationSystem",       // NavMesh
    "StateTreeModule",        // State Machine
    "GameplayStateTreeModule",// Gameplay State Tree
    "UMG",                    // UI Widget
    "Slate"                   // Slate UI Framework
});

// ì£¼ì„ ì²˜ë¦¬ëœ ëª¨ë“ˆë“¤
// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
```

### ì£¼ìš” ì‹œìŠ¤í…œ í™œìš©

**1. Navigation System**
- NavMesh ê¸°ë°˜ AI ì´ë™
- GetRandomReachablePointInRadius()ë¡œ ë°°íšŒ êµ¬í˜„

**2. UMG (Unreal Motion Graphics)**
- 3D Widget Componentë¥¼ í†µí•œ POS UI
- ì†ë‹˜ ë§í’ì„  UI
- ì£¼ë¬¸ ê´€ë¦¬ ì¸í„°í˜ì´ìŠ¤

**3. Enhanced Input System**
- Input Action ê¸°ë°˜ ì…ë ¥ ì²˜ë¦¬
- Input Mapping Contextë¡œ ìƒí™©ë³„ ì…ë ¥ ì „í™˜

**4. Replication System**
- Actor/Component ë ˆë²¨ ë³µì œ
- Server/Client/Multicast RPC
- Replicated Movement for Physics

---

## ğŸ“Š ì„±ëŠ¥ ìµœì í™”

### 1. ë„¤íŠ¸ì›Œí¬ ìµœì í™”
- **Authority ì²´í¬**: ì„œë²„ì—ì„œë§Œ ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” ë¡œì§ ë¶„ë¦¬
- **ì„ íƒì  ë³µì œ**: í•„ìš”í•œ ë°ì´í„°ë§Œ ë³µì œ
- **RPC ìµœì†Œí™”**: ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸ í˜¸ì¶œì„ í•˜ë‚˜ì˜ Multicastë¡œ í†µí•©

### 2. AI ìµœì í™”
- **íƒ€ì´ë¨¸ ê¸°ë°˜ ì—…ë°ì´íŠ¸**: Tick ëŒ€ì‹  íƒ€ì´ë¨¸ë¡œ ë°°íšŒ ë¡œì§ ì²˜ë¦¬
- **NavMesh ìºì‹±**: ì´ë™ ê²½ë¡œ ì¬ê³„ì‚° ìµœì†Œí™”

### 3. ë¬¼ë¦¬ ìµœì í™”
- **Collision Profile í™œìš©**: ìƒí™©ì— ë§ëŠ” ì¶©ëŒ ì„¤ì •
- **Physics Sleep**: ì •ì§€ ì‹œ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì§€

---

## ğŸ“ í•™ìŠµ í¬ì¸íŠ¸ ë° ë„ì „ ê³¼ì œ

### ì„±ê³µì ìœ¼ë¡œ êµ¬í˜„í•œ ê¸°ëŠ¥

1. **ì•ˆì •ì ì¸ ë©€í‹°í”Œë ˆì´ì–´ ë™ê¸°í™”**
   - ë¦¬ìŠ¨ ì„œë²„ ì•„í‚¤í…ì²˜ êµ¬í˜„
   - RPCë¥¼ í†µí•œ ìƒíƒœ ë™ê¸°í™”
   - ë¬¼ë¦¬ ê°ì²´ì˜ ë„¤íŠ¸ì›Œí¬ ë³µì œ

2. **ìœ ì—°í•œ AI ì‹œìŠ¤í…œ**
   - FSM ê¸°ë°˜ ì†ë‹˜ í–‰ë™
   - ëŒ€ê¸°ì—´ ê´€ë¦¬ ì‹œìŠ¤í…œ
   - í”½ì—… ë° ê²€ì¦ ì‹œìŠ¤í…œ

3. **ì§ê´€ì ì¸ ì¡°ë¦¬ ì‹œìŠ¤í…œ**
   - ë¬¼ë¦¬ ê¸°ë°˜ ì¬ë£Œ ìƒí˜¸ì‘ìš©
   - íƒ€ì´ë¨¸ ê¸°ë°˜ ì¡°ë¦¬ ìƒíƒœ ì „í™˜
   - ë ˆì‹œí”¼ ê²€ì¦ ì•Œê³ ë¦¬ì¦˜

### í•´ê²°í•œ ê¸°ìˆ ì  ë„ì „

**ë¬¸ì œ 1: ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™” ë¶ˆì¼ì¹˜**
- **ì›ì¸**: í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì§ì ‘ Actor ìƒíƒœ ë³€ê²½
- **í•´ê²°**: Server RPC â†’ Multicast RPC ì²´ì¸ìœ¼ë¡œ ì¤‘ì•™í™”

**ë¬¸ì œ 2: AI ë°°íšŒ ì‹œ ì¤‘ë³µ ì´ë™**
- **ì›ì¸**: Tickë§ˆë‹¤ ìƒˆë¡œìš´ ëª©ì ì§€ ì„¤ì •
- **í•´ê²°**: íƒ€ì´ë¨¸ ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬ë¡œ ë³€ê²½

**ë¬¸ì œ 3: ë¬¼ë¦¬ ê°ì²´ ë³µì œ ë¬¸ì œ**
- **ì›ì¸**: í´ë¼ì´ì–¸íŠ¸ì—ì„œë„ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ í™œì„±í™”
- **í•´ê²°**: Authority ì²´í¬ í›„ í´ë¼ì´ì–¸íŠ¸ëŠ” ë¬¼ë¦¬ off

---

## ğŸš€ í–¥í›„ ê°œì„  ë°©í–¥

### ê³„íšëœ ê¸°ëŠ¥
- [ ] **í‰íŒ ì‹œìŠ¤í…œ**: ì†ë‹˜ ë§Œì¡±ë„ì— ë”°ë¥¸ ì ìˆ˜ ê´€ë¦¬ (ShowReputationText í•¨ìˆ˜ êµ¬í˜„ë¨)
- [ ] **ë‚œì´ë„ ì¡°ì ˆ**: ì†ë‹˜ ìŠ¤í° ë¹ˆë„, ì£¼ë¬¸ ë³µì¡ë„ ì¡°ì ˆ (MaxSpawnedCustomers ë³€ìˆ˜ ì¡´ì¬)
- [ ] **ì¶”ê°€ ë©”ë‰´**: ì‚¬ì´ë“œ ë©”ë‰´, ìŒë£Œ ì‹œìŠ¤í…œ
- [ ] **ì‹œê°„ ì œí•œ ëª¨ë“œ**: ì œí•œ ì‹œê°„ ë‚´ ìµœëŒ€í•œ ë§ì€ ì£¼ë¬¸ ì²˜ë¦¬
- [ ] **í”½ì—… í˜¸ì¶œ ì‹œìŠ¤í…œ ê°œì„ **: í˜„ì¬ TODOë¡œ ë‚¨ì•„ìˆëŠ” ì†ë‹˜ í˜¸ì¶œ ê¸°ëŠ¥ ì™„ì„±

### ê¸°ìˆ ì  ê°œì„ 
- [ ] **ë°ë””ì¼€ì´í‹°ë“œ ì„œë²„**: ì „ìš© ì„œë²„ êµ¬ì¶•
- [ ] **Save/Load**: ì§„í–‰ìƒí™© ì €ì¥ ì‹œìŠ¤í…œ
- [ ] **ë ˆë²¨ ìŠ¤íŠ¸ë¦¬ë°**: ëŒ€í˜• ë§µì„ ìœ„í•œ ë™ì  ë¡œë”©
- [ ] **UI ê°œì„ **: ë” ì§ê´€ì ì¸ ì£¼ë¬¸ ì¸í„°í˜ì´ìŠ¤

---

## ğŸ“ ì½”ë“œ êµ¬ì¡°

```
Source/MHGA/
â”œâ”€â”€ Public/
â”‚   â”œâ”€â”€ AI/
â”‚   â”‚   â”œâ”€â”€ CustomerAI.h          # ì†ë‹˜ ìºë¦­í„°
â”‚   â”‚   â”œâ”€â”€ CustomerFSM.h         # ì†ë‹˜ FSM
â”‚   â”‚   â”œâ”€â”€ CustomerManager.h    # ì†ë‹˜ ìƒì„±/ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ CustomerUI.h          # ì†ë‹˜ UI
â”‚   â”œâ”€â”€ Counter/
â”‚   â”‚   â”œâ”€â”€ CounterPOS.h          # POS ì‹œìŠ¤í…œ
â”‚   â”‚   â”œâ”€â”€ CounterUI.h           # POS UI
â”‚   â”‚   â”œâ”€â”€ MenuButtonUI.h        # ë©”ë‰´ ë²„íŠ¼
â”‚   â”‚   â”œâ”€â”€ CustomerButtonUI.h   # ì£¼ë¬¸ ë²„íŠ¼
â”‚   â”‚   â”œâ”€â”€ PickupZone.h          # í”½ì—… êµ¬ì—­
â”‚   â”‚   â””â”€â”€ ReceiptActor.h        # ì˜ìˆ˜ì¦
â”‚   â”œâ”€â”€ Ingredient/
â”‚   â”‚   â”œâ”€â”€ IngredientBase.h      # ì¬ë£Œ ë² ì´ìŠ¤ í´ë˜ìŠ¤
â”‚   â”‚   â”œâ”€â”€ Patty.h               # íŒ¨í‹° (ì¡°ë¦¬ ìƒíƒœ)
â”‚   â”‚   â”œâ”€â”€ SauceBottle.h         # ì†ŒìŠ¤ ë³‘
â”‚   â”‚   â””â”€â”€ [ê¸°íƒ€ ì¬ë£Œë“¤]
â”‚   â”œâ”€â”€ Player/
â”‚   â”‚   â”œâ”€â”€ MHGACharacter.h       # í”Œë ˆì´ì–´ ìºë¦­í„°
â”‚   â”‚   â”œâ”€â”€ MHGAPlayerController.h# í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬
â”‚   â”‚   â”œâ”€â”€ InteractComponent.h   # ìƒí˜¸ì‘ìš© ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â””â”€â”€ PlayerAnim.h          # ì• ë‹ˆë©”ì´ì…˜
â”‚   â”œâ”€â”€ Props/
â”‚   â”‚   â”œâ”€â”€ Flipper.h             # ë’¤ì§‘ê°œ
â”‚   â”‚   â””â”€â”€ IngContainer.h        # ì¬ë£Œ ì»¨í…Œì´ë„ˆ
â”‚   â”œâ”€â”€ BurgerData.h              # ë°ì´í„° ì •ì˜
â”‚   â”œâ”€â”€ CookingArea.h             # ì¡°ë¦¬ ì˜ì—­
â”‚   â”œâ”€â”€ GrabableProps.h           # ìƒí˜¸ì‘ìš© ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ Hamburger.h               # ì™„ì„±ëœ í–„ë²„ê±°
â”‚   â”œâ”€â”€ WrappingPaper.h           # í¬ì¥ì§€
â”‚   â”œâ”€â”€ MHGAGameMode.h            # ê²Œì„ ëª¨ë“œ
â”‚   â””â”€â”€ MHGAGameState.h           # ê²Œì„ ìŠ¤í…Œì´íŠ¸
â””â”€â”€ Private/
    â””â”€â”€ [ëŒ€ì‘ë˜ëŠ” .cpp íŒŒì¼ë“¤]
```

---

## ğŸ“§ ì—°ë½ì²˜

**í”„ë¡œì íŠ¸ íŒ€**
- ê¹€í™ë²”
- í™©ê·œí™˜
- í—ˆì§€ì›…

**ê¹ƒí—ˆë¸Œ ì €ì¥ì†Œ**
- https://github.com/4thWanted/MHGA
- https://github.com/khb532/MHGA

---

## ğŸ“œ ë¼ì´ì„ ìŠ¤

Copyright Epic Games, Inc. All Rights Reserved.

---

**ë³¸ ë¬¸ì„œëŠ” í¬íŠ¸í´ë¦¬ì˜¤ ìš©ë„ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, í”„ë¡œì íŠ¸ì˜ ì£¼ìš” ê¸°ìˆ ì  êµ¬í˜„ ì‚¬í•­ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.**
